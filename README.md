## Задача 1. Робот-доставщик

## Описание

Представьте, что перед вашей командой поставили задачу разработать программное обеспечение для робота-доставщика. Инструкции для робота содержат команды:

- R — поверни направо;
- L — поверни налево;
- F — двигайся вперёд.

В процессе построения карты маршрутов вам поручили проанализировать разнообразие существующих путей.
Для генерации маршрутов вы используете функцию:

```java
    public static String generateRoute(String letters, int length) {
        Random random = new Random();
        StringBuilder route = new StringBuilder();
        for (int i = 0; i < length; i++) {
            route.append(letters.charAt(random.nextInt(letters.length())));
        }
        return route.toString();
    }
```
Напишите многопоточную программу, которая в каждом потоке:

- генерирует текст `generateRoute("RLRFR", 100)`;
- считает количество команд поворота направо (буквы `'R'`);
- выводит на экран результат.

Количество потоков равно количеству генерируемых маршрутов и равно `1000`.

Так как буква `'R'` в параметре генератора упомянута три раза из пяти, то в среднем, количество букв `'R'` должно составлять 60% от всех команд инструкции, т. е.  около 60-ти от общего числа маршрутов.

Но т. к. процесс вероятностный, точное количество раз, которое встретится эта буква в каждом маршруте, может немного отклоняться от среднего значения.

Запустив программу, вы обратили внимание, что размеры промежутков с буквой `'R'` часто повторяются, и вам стало интересно, какие размеры попадаются чаще всего.

Для этого вы завели мапу в статическом поле `public static final Map<Integer, Integer> sizeToFreq`, которая после завершения потоков должна хранить в ключах попавшиеся частоты буквы `'R'`, а в значениях — количество раз их появления.

После обработки каждой строки вам нужно будет обновить эту мапу, увеличив значение для полученной частоты в ней на 1, а если частоты в мапе не было — только вставить значение 1.

Возникает проблема — `Map` не потокобезопасна, к ней нельзя обращаться из разных потоков одновременно.

Решением этой проблемы будет использование блока синхронизации (`synchronized`).

Реализуйте этот функционал и в конце основного потока выведите сообщение вида:

```text
Самое частое количество повторений 61 (встретилось 9 раз)
Другие размеры:
- 60 (5 раз)
- 64 (3 раз)
- 62 (6 раз)
...
```
## Реализация

1. Заведите мапу в статическом поле `public static final Map<Integer, Integer> sizeToFreq`.
2. При обработке каждой строки увеличьте счётчик в `Map`.
3. Используйте `synchronized` для потокобезопасного доступа к `Map`.

## Задача 2. Частота операций

## Описание

В процессе создания программы для робота-доставщика вы решили сделать так, чтобы при каждом обновлении мапа `sizeToFreq` на экран выводился бы текущий лидер среди частот. Для этого придётся просматривать весь `Map` в поисках лидера, что достаточно затратно.

Вместо того, чтобы делать это в том же потоке, что и считал размер, заведите отдельный поток, который будет заниматься только подсчётом максимума в мапе и выводом этой информации на экран.

Делать это он будет в цикле, а чтобы подсчёт и вывод происходили только когда нужно, он будет ждать «сигнала» через `wait-notify` от считающих потоков.

Условием цикла поставьте проверку на то, что поток не прервали. В основном потоке после `for` с `join` прервите этот выводящий максимумы поток.

## Реализация

Эта задача выполняется на основе первой задачи этого домашнего задания. Отведите для неё новую ветку `freqlog`.

1. Создайте отдельный поток для вывода на экран лидера в мапу `sizeToFreq`.
2. В этом потоке должен быть реализован бесконечный цикл с проверкой на прерванность `while (!Thread.interrupted()) { ... }`.
3. В цикле перед каждым поиском и выводом на экран максимума в мапе `sizeToFreq` поток должен ждать сигнала от заполняющих мапу потоков.
4. В заполняющих мапу потоках добавьте отправку сигнала печатающему максимумы потоку.
5. После завершения всех считающих потоков прервите печатающий поток через `thread.interrupt()`.